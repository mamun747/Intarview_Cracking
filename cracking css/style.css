/* step 1 starts */

/* 1| What is CSS, and how does it work with HTML? */
/* ans: CSS, or Cascading Style Sheets, is used to style HTML elements by selecting them with specific selectors. To apply CSS to an HTML file, we link the CSS file in the <head> section using the <link> tag. This separates structure (HTML) from styling (CSS). */


/* 2| What is the difference between inline, internal, and external CSS? */
/* ans: 
# Inline CSS:- Styles are applied directly within an HTML element using the style attribute.
# Internal CSS:- Styles are placed within a <style> tag in the HTML document’s <head> section, affecting only that document.
# External CSS:- Styles are written in a separate .css file linked to the HTML, allowing the same styles to be reused across multiple pages.
 */

/* 3| Explain the CSS box model. What properties does it consist of? */
/* ans: The CSS box model represents the layout of HTML element as rectangular boxes with four main properties:-
# Content:- The actual content inside the box, like text or images.
# Padding:- Space between the content and the border.
# Border:- The edge surrounding the padding.
# Margin:- Space outside the border, separating the element from others.
*/

/* 4| What is specificity in CSS, and how does it affect styling? */
/* ans: Specificity in CSS is the weight given to a selector, determining which styles are applied when multiple rules target the same element. Inline styles have the highest specificity (1000), followed by IDs (100), classes (10), and elements (1). Higher specificity selectors override lower ones, impacting which styles are ultimately applied. */

/* 5| How do CSS selectors work, and what are some common types of selectors? */
/* and: CSS selectors target HTML elements to apply styles. Common selectors include:
# ID selector (#) targets a specific element by its unique ID.
# Class selector (.) targets elements with a specific class.
# Element selector targets all instances of a tag (e.g., div, p). */

/* 6| What are pseudo-classes and pseudo-elements? Give examples of each. */
/* ans: 
1| Pseudo-classes are used to define a special state of an element. For example:
:hover applies styles when the mouse hovers over an element.
:nth-child(n) selects elements based on their order within a parent.

2| Pseudo-elements allow you to style a specific part of an element. For example:
::before inserts content before the element’s content.
::after inserts content after the element’s content.
 */

/* 7| Explain the concept of inheritance in CSS. */
/* and: Inheritance in CSS refers to the way certain properties are passed down from parent elements to child elements. For example, if a parent element has a font color set, all child elements will inherit that color unless overridden. Properties like color, font-family, and line-height are typically inherited, while properties such as margin, padding, and border are not. This concept helps maintain consistency in styling across a webpage and reduces the need for repetitive code. */

/* 8| What is the !important rule in CSS, and when should you use it? */
/* ans: The !important rule in CSS forces a style to take precedence over others, regardless of specificity. For example:
    p {
        color: red !important;
    }
 */

/* step 1 completed */

/* step 2 starts */

/* 1| How does the display property work, and what are the different display values? */
/* ans: 
The display property controls how an element is rendered on the page. Common values include:-
# block: Takes up the full width, starting on a new line.
# inline: Takes only the necessary width, staying in line with other elements.
# inline-block: Acts like inline but can have width and height set.
# none: Hides the element completely.
*/

/* 2| What is the position property, and how do different position values (static, relative, absolute, fixed, sticky) behave? */
/* ans:  
The position property defines how an element is placed on the page. Key values include:-
# static: Default, positioned based on the normal document flow.
# relative: Positioned relative to its original location.
# absolute: Positioned relative to its nearest positioned ancestor, removed from the document flow.
# fixed: Positioned relative to the viewport; stays fixed when scrolling.
# sticky: Behaves like relative until a scroll threshold, then sticks in place.
*/

/* 3| How do the padding, margin, and border properties work in CSS? */
/* ans:
# Padding: Creates space inside an element, between the content and the border.
# Border: Surrounds the padding and content, defining the edge of the element.
# Margin: Creates space outside the border, separating the element from other elements.
*/

/* 4| Explain the flex property. How do flex-grow, flex-shrink, and flex-basis work? */
/* ans:-
The flex property is used in flexbox layouts to control how a flex item behaves in available space. It consists of:
# flex-grow: Defines how much an item can grow relative to others (e.g., 1 means it can grow if there’s space).
# flex-shrink: Controls how much an item can shrink if space is limited.
# flex-basis: Sets the initial size of an item before any growing or shrinking occurs.
 */

/* 5| What is the difference between width, min-width, and max-width? */
/* ans:-
# width: Sets an element’s exact width.
# min-width: Sets the minimum width, preventing the element from becoming smaller than this value.
# max-width: Sets the maximum width, restricting the element from growing beyond this value
*/

/* 6| How does the z-index property work, and when would you use it? */
/* ans:- The z-index property controls the stacking order of positioned elements (e.g., relative, absolute, fixed). Higher z-index values appear on top of lower ones. It’s useful for layering elements, like placing a modal above the page content or bringing one element in front of another.
*/

/* 7|  What is the difference between the opacity and visibility properties? */
/* ans:-
# opacity: Controls an element’s transparency, with 0 being fully transparent and 1 fully visible, but the element still occupies space.
# visibility: Controls whether an element is visible (visible) or hidden (hidden). A hidden element does not display but still occupies space in the layout.
*/

/* step 2 completed */

/* step 3 starts */

/* 1| What is the difference between flexbox and CSS Grid, and when should you use each? */
/* ans: Flexbox is a one-dimensional layout system, working in either a row or column, making it ideal for aligning items in a single direction. CSS Grid is a two-dimensional system, managing layouts in both rows and columns, so it’s suited for more complex page layouts. Use Flexbox for simple, linear layouts and Grid for more complex, multi-directional designs.*/

/* 2| Explain how to create a responsive layout using media queries. */
/* ans:  To create a responsive layout, media queries in CSS allow specific styles to be applied based on the device’s screen width (e.g., mobile, tablet, laptop). For example, a flex container might display as a column on mobile screens by setting a breakpoint with @media (max-width: 600px), adjusting the layout to fit smaller screens. This approach enables layout adjustments and improves usability across various devices. */

/* 3| How do you create a centered element in CSS? Provide multiple ways. */
/* ans: we can center a element by following some ways: the ways is write in below:-
# Flexbox: Use display: flex with justify-content: center and align-items: center to center an element.
# Grid: Use display: grid with place-items: center or justify-items: center and align-items: center.
# Margin: For block elements, use margin: auto to center horizontally.
*/

/* 4| How does CSS Grid work, and what are grid-template-rows and grid-template-columns? */
/* ans: CSS Grid is a two-dimensional layout system that allows you to create layouts using rows and columns. The grid-template-rows property defines the number and size of rows in a grid container, while grid-template-columns specifies the number and size of columns. Together, they help structure the grid layout, allowing for complex designs with precise control over placement.*/

/* 5| How does the flex-direction property work in Flexbox, and what are its values? */
/* ans: The flex-direction property in Flexbox defines the direction of the flex container's main axis, allowing layouts to be created in one dimension. It can take the following values:
# row: Aligns items horizontally (default).
# row-reverse: Aligns items horizontally in reverse order.
# column: Aligns items vertically.
# column-reverse: Aligns items vertically in reverse order.*/

/* 6| What is a viewport, and how do you make elements responsive to viewport changes? */
/* ans: The viewport is the visible area of a webpage on a device screen. To make elements responsive to viewport changes, you can use relative units like percentages (%), viewport width (vw), and viewport height (vh). Additionally, media queries can adjust styles at specific viewport widths, ensuring the layout adapts to different screen sizes for better user experience. */

/* 7| How can you create a sticky footer that stays at the bottom of the page? */
/* ans:  
To create a sticky footer that remains at the bottom of the page, you can use the following CSS approach:
Set the footer's position to fixed or sticky, depending on your needs.
Ensure the footer's bottom property is set to 0.
Here's a simple example:
footer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
}
*/

/* 8| Explain how you would approach creating a mobile-first design */
/* ans: 
To create a mobile-first design, I would follow these steps:

1| Start with Mobile Styles: Begin by writing CSS for the smallest screens first, focusing on essential content and functionality.
2| Use Media Queries: Implement media queries to add styles for larger screens, progressively enhancing the design. For example:
@media (min-width: 768px) {
    Styles for tablets and larger screens
}
3| Flexible Layouts: Use relative units like percentages and vw/vh for widths and heights to ensure elements resize fluidly across different screen sizes.
4| Responsive Images: Utilize responsive images with max-width: 100% to ensure they scale with their containers.
5| Test on Devices: Continuously test the design on various devices and screen sizes to ensure usability and accessibility.

/* step 3 completed */

/* step 4 starts */

/* 1| What do you understand by the universal sector? */
/* ans: The universal selector (*) targets all elements within the document, applying styles to every element by default. It’s useful for setting global styles, such as margin, padding, or box-sizing, to ensure a consistent baseline across all elements. For example:-
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

*/

/* 2| What are CSS preprocessors, and how do they work? Give examples like SASS or LESS. */
/* ans: CSS preprocessors are scripting languages that extend CSS, allowing for variables, nesting, functions, and other features that make writing CSS more efficient and maintainable. Preprocessors like SASS and LESS compile into standard CSS that browsers can read.
For example, in SASS, you can use variables for colors and nest selectors for cleaner code:
$primary-color: #3498db;

nav {
  background: $primary-color;
  ul {
    list-style: none;
  }
}

This code compiles to regular CSS, making styling faster and easier to manage in larger projects.
*/

/* 3| Explain CSS custom properties (CSS variables) and their benefits. */
/* ans: CSS custom properties, or CSS variables, allow you to define reusable values within your CSS using the -- prefix. For example:
:root {
  --primary-color: #3498db;
}

button {
  background-color: var(--primary-color);
}

Benefits:
# Reusability: Update a value in one place to change it throughout the stylesheet.
# Dynamic Styling: CSS variables can be updated with JavaScript for real-time changes.
# Scoped Usage: Variables can be scoped to specific elements, offering flexibility for theme management.
*/

/* 4| How do CSS animations work, and how can you create a keyframe animation? */
/* ans: CSS animations allow you to animate HTML elements by transitioning between different styles over time. You create animations using the @keyframes rule to define the states of the animation and the animation property to apply it to an element.

Steps to create a keyframe animation:
1| Define Keyframes: Use the @keyframes rule to specify the animation states. For example:
@keyframes example {
    0% {
        transform: translateX(0);
        opacity: 1;
    }
    100% {
        transform: translateX(100px);
        opacity: 0;
    }
}

2| Apply Animation: Use the animation property on the target element to apply the keyframe animation:
.animated-element {
    animation: example 2s ease-in-out forwards;
}

Explanation:
# example: The name of the animation.
# 2s: Duration of the animation.
# ease-in-out: Timing function for smooth transitions.
# forwards: Maintains the final state of the animation.
*/

/* 5| What are CSS transitions, and how are they different from animations? */
/* ans: CSS transitions allow for smooth changes between property values when an element's state changes, such as on hover. For example:
.box {
    background-color: blue;
    transition: background-color 0.5s ease;
}

.box:hover {
    background-color: red;
}

Differences between CSS transitions and animations:

# Triggering:
Transitions occur on state changes, like hovering or focusing.
Animations run automatically based on defined keyframes.

# Control:
Transitions are simpler and typically control one or two properties.
Animations allow for multiple keyframes and property changes over time.

# Keyframes:
Transitions do not use keyframes; they only transition between two states.
Animations utilize @keyframes to define multiple states throughout the animation.
*/

/* 6| What is the difference between rem, em, and px units? */
/* ans: The units rem, em, and px are used to define sizes in CSS, but they behave differently:
1| px (Pixels):
# A fixed unit that represents a specific number of pixels on the screen.
# Does not scale based on the user's settings or the font size of parent elements.

2| em:
# A relative unit based on the font size of the element’s parent.
# If the parent’s font size is 16px, 1em equals 16px. If a child element has a font size of 2em, it will be 32px (2 × 16px).

3| rem (Root em):
# A relative unit based on the font size of the root element (<html>), making it consistent across the entire document.
# If the root font size is 16px, 1rem equals 16px, regardless of the font size of parent elements.
*/

/* 7| What is SVG and how can it be used to create custom shapes? */
/* ans: SVG (Scalable Vector Graphics) is an XML-based vector image format used for defining two-dimensional graphics. Unlike raster images (like JPEG or PNG), SVGs are resolution-independent, meaning they can scale without losing quality, making them ideal for responsive web design.

Creating Custom Shapes with SVG:
1| Basic Shapes: SVG provides built-in elements for shapes like <circle>, <rect>, <line>, <polygon>, and <path>. For example, to create a circle:
<svg width="100" height="100">
    <circle cx="50" cy="50" r="40" fill="blue" />
</svg>

2| Custom Paths: The <path> element allows for the creation of complex shapes using a series of commands in the d attribute. For example:
<svg width="100" height="100">
    <path d="M10 10 H 90 V 90 H 10 L 10 10" fill="red" />
</svg>

3| Styling: SVG shapes can be styled using CSS, allowing for fill colors, strokes, and other effects, just like HTML elements.

4| Interactivity: SVG can be manipulated via JavaScript, enabling dynamic and interactive graphics.

*/

/* step 4 completed */


/* The End */